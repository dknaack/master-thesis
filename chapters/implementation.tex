\chapter{Experimental Analysis on the Periodicity}

In this chapter, we consider the problem of finding a periodic MDCF for an algebraic number of degree $d+1$.
Finding a proof, that algebraic numbers of degree $≤ d+1$ always admit periodic MDCFs, is much more difficult.
We have already seen that the golden ratios are periodic, when running the
generalized Euclidean algorithm on them.
In this chapter, I present my empirical results on some cubic roots.
I have implemented the generalized Euclidean algorithm and used it to look for
cubic roots.
In this chapter, I present the results of my analysis.

\section{Experiment Setup}

Recall that Hermite's original question asks about the representation of a
single number $r ∈ ℝ$, but the generalized Euclidean algorithm expects a vector
as input.
So we first need a mapping from a real number $r$ to a real vector $x$.
One solution is to apply a set of $d$ polynomials $q₁, …, q_d$ on the
given number $r$ giving us the vector $x = (q₁(r), …, q_d(r))$.
Not all choices work equally well -- a trivial example, which won't work, would
be choosing constant polynomials, i.e. $qᵢ(r) = c_i$ for $c_i ∈ ℚ$.
Therefore, the polynomials should be chosen such that when $r$ is an algebraic
number of degree $≥d+1$, the elements of $x$ are linearly independent with
rational coefficients.
An easy way to achieve this is to choose polynomials with different degrees or
more specifically $\deg(q_i) = i$.
In my analysis, I have always chosen the polynomials $qᵢ(r) = r^i$.
Unless stated otherwise, the following analysis will always use this vector as the input.

\begin{Pseudocode}[float=tbp, label={lst:bfs}, caption={The brute-force search algorithm for finding a periodic representation.}]
algorithm $\textsc{brute-force-search}(x, N)$
  for $L ∈ \{1, …, d\}^{≤ N}$ do
    $x₀ ← x$
    for $i ∈ \{1, …, |L|\}$ do
      $x_i ← \mathrm{pivot}_{L[i]}(x_{i-1})$
      if $x_i$ occurred twice then
        Find the index $j ≠ i$ where $x_j = x_i$
        $S ← L[1] \,…\, L[j]$
        $P ← L[j+1] \,…\, L[i]$
        return $(S, P)$
  return $ε$
\end{Pseudocode}

Now that we have a vector $x$, we can begin the search.
The pseudocode for the search algorithm I implemented is shown in Listing~\ref{lst:bfs}.
The algorithm is a brute-force search over all possible sequences $\{1,\dots,d\}^*$.
We simply try every sequence of possible pivot indices in a breadth-first manner.
So we begin with all sequences of length $1$ and see if any vector occurs twice.
If not, then we continue with all sequences of length $2$ and check again if
any previous vector has occurred twice.
We continue this process indefinitely until we hopefully find a duplicate vector.

\section{Results for Cubic Irrationals}

For cubic irrationals there are $2^n$ possible sequences,
so the search is already quite expensive.
The search for the first 30 cube roots took roughly one hour to complete.

\begin{example}
  The sequences for the prime numbers are:
  \begin{itemize}
    \item $2^{1/3}$: $0\overline{10}$.
    \item $3^{1/3}$: $01\overline{01}$.
    \item $5^{1/3}$: $0\overline{00111000}$.
    \item $7^{1/3}$: $0\overline{010100}$.
    \item $11^{1/3}$: $0\overline{1100}$.
    \item $13^{1/3}$: $00\overline{010000}$.
    \item $17^{1/3}$: $000\overline{11110000}$.
    \item Another choice for $5^{1/3}$ with shorter period: $00110\overline{101010}$.
  \end{itemize}
\end{example}

\begin{remark}
  The first number that has a leading $1$ as the pivot is $12$,
  which has the pivot sequence $1\overline{0111011101}$.
  However, there are other possible choices where it does not have a leading $0$.
\end{remark}

\begin{table}[t]
  \caption{Representation of $ψ = \sqrt[3]{4}$ using the brute-force search.}
  \label{table:cube-root-4}
  \centering
  \input{tables/cube-root-4.tex}
\end{table}

\begin{table}[t]
  \caption{Period Length of the first $28$ numbers.}
  \centering
  \input{tables/period-length.tex}
\end{table}

\section{Results for Quartic and Higher-Degree Irrationals}

\section{Evaluation of More Efficient Search Strategies}

We can likely rule out alternating pivot sequences since this corresponds to
the Jacobi-Perron algorithm and for this algorithm it is conjectured
\cite{Karpenkov21} that the algorithm is not periodic for $\sqrt[3]{4}$.
However, the brute-force algorithm is periodic for this input (see Table~\ref{table:cube-root-4}).

The choice of the initial input also matters.
We generally choose $x = (α, q(α))$, where $q$ is some polynomial of degree $2$.
But different choices of $q$ produce different sequences.
For example, $(\sqrt[3]{2}, \sqrt[3]{4})$ produces a different sequence of coefficients than $(\sqrt[3]{2}, \sqrt[3]{6})$.
Even though both inputs represent the same number $\sqrt[3]{2}$.
Choosing $q(α) = α^2 - α$ makes the sequence purely periodic for $\sqrt[3]{3}$ and $\sqrt[3]{4}$.

The strategy is given the initial input $x ∈ ℝ^d$ and a sequence of indices $L ∈ \{1, …, d\}^*$ and must
return all valid indices which can be appended to the current sequence to form
a new sequence.
For the brute-force search, the strategy always outputs the entire set; any index is allowed.
The minimum strategy only outputs one index and its the one where $x^{(n)}$ has
the minimum fractional value, if $n$ is the length of the list $L$.
\[
  S \colon ℝ^d × \{1, …, d\}^* → \mathcal P(\{1, …, d\}), (x, L) ↦ \{ℓ_1, …, ℓ_k\}.
\]

The main goal of the brute-force search was to find a periodic representation for a cubic root at all.
The hope is that the sequences share something in common such that we can find
a more optimized search strategy, ideally one which can be decided without
trying every possible combination.
Therefore, two more types of searches were studied.
The first type is a deterministic search,
which only looks at one possible path in the tree.
For example, the minimum strategy would only look at one possible path.
The other type is a non-deterministic search,
which looks at multiple paths simultaneously.
For this type of search, the main point of interest was the approximation rate of the convergents
and whether convergents are the best rational approximations of the original input vector $x$,
i.e. whether they fulfill
\[
  |x_i - \frac{p_i^{(n)}}{q^{(n)}}| < \frac{1}{q^{(n)} \sqrt[d]{q^{(n)}}}, \text{ for every } i ≤ d
\]
at each step.
The idea would be that this could be one possible optimization to the brute-force search.
Instead of trying every possible candidate, we only choose paths which lead to good approximations.
For $d = 1$, this is already known by Lemma~\ref{lem:cf-approx},
but for higher dimensions it is not known whether the convergents are good
approximations, yet.

For the deterministic search, a strategy $s$ is a function $R^d → \{1, …, d\}$
which takes in the complete quotient $x^{(n)} ∈ ℝ^d$ of the input vector $x ∈ R^d$
and the number of iterations $n$.
The strategy outputs only a single index $ℓ$,
which is used to find the next complete quotient by $x^{(n+1)} =
\mathrm{pivot}_ℓ(x^{(n)})$.
For example, the minimum strategy would be defined as
\[
  s(x, n) = \underset{\substack{ℓ ∈ \{1, …, d\} \\ \{x_ℓ\} ≠ 0}}{\text{arg min}} \{x_ℓ\}.
\]
The additional index $n$ is used for example in the Jacobi-Perron algorithm,
which chooses always the next index in the sequence.
So,
\[
  s(x, n) = (n \bmod d) + 1.
\]

In summary, the following deterministic strategies were tried:
\begin{itemize}
  \item Minimum fractional value
  \item Maximum fractional value
  \item Strategies which are regular: $s(x, n) = ((n + k) \bmod d) + 1$ for all $k ≤ d$.
    This includes the Jacobi-Perron algorithm which sets $k = 0$.
  \item Some other paper, which decides the next candidate
    based on the algebraic norm of the underlying field. % TODO: Find the paper
\end{itemize}

For the non-deterministic search, only the approximation criterion was tested,
but with different rates, i.e. whether for some constant $c ≥ 1$,
\[
  |x_i - \frac{p_i^{(n)}}{q^{(n)}}| < \frac{c}{q^{(n)} \sqrt[d]{q^{(n)}}}, \text{ for every } i ≤ d.
\]

