\chapter{Experimental Analysis on Multidimensional Continued Fractions}
\label{ch:implementation}

In the previous chapter, we have analyzed
In particular, we saw that most MDCFs converge,
and that any periodic MDCF consists of algebraic numbers.
The former solves the first part of Hermite's question, but the latter solves
only one direction of the second part.
The first part of this chapter will focus on the remaining direction:
whether every algebraic number admits a periodic MDCF.

We have already seen in Chapter~\ref{ch:fibonacci},
that the simplest periodic MDCFs can be considered a generalization of the
golden ratio.
The first part of this chapter extends this result by presenting further
examples of periodic MDCF for algebraic numbers.
These include a wide range of cube roots,
all of which appear to have periodic representations under one particular strategy.
While this does not amount to a proof, the evidence strongly supports
the possibility of a positive answer to the second part of Hermite’s question.

The second part of this chapter focuses on the approximation rate of MDCFs.
For ordinary continued fractions, the convergents are known to give
exceptionally good approximations to irrational numbers.
Here, we test whether MDCFs offer similar approximation behavior in higher dimensions.

\iffalse
% ==============================================================================
\section{Implementation details}
% ==============================================================================

% ==============================================================================
\begin{Python}[
    float=tbp,
    numbers=left,
    label={lst:bfs},
    caption={
      The implementation of the brute-force search for finding a periodic representation.
      The program iterates over all sequences with a maximum length of $N$
      until it finds a duplicate vector.
    }
  ]
def brute_force_search(x, N):
  d = len(x)
  indices = list(range(d))
  for n in range(N):
    for L in product(indices, repeat=n):
      y = x
      seen = {y: 0}
      for i in range(n):
        y = pivot(y, L[i])
        if y in seen:
          j = seen[y]
          start = L[:j]
          period = L[j:i+1]
          return start, period
        seen[y] = i + 1
\end{Python}
% ==============================================================================

% Brute-force search
The goal is to find a periodic MDCF for some algebraic number $α$.
For an MDCF, we require a sequence of indices $ℓ₁, ℓ₂, …$ which determine the
element to pivot with.
To find this sequence, different types of searches were constructed.

The program is an implementation of the generalized Euclidean algorithm
in Python and SageMath.
More specifically, only the pivot operation from the algorithm was implemented,
since this the actual part that is relevant for the construction of an MDCF.

The actual code for the search I implemented is shown in Listing~\ref{lst:bfs}.
The input to the algorithm is a vector $x$ containing algebraic numbers of
degree $≤ d+1$ and a maximum search depth $N$.
If possible, it outputs two index sequences of the start and period for a periodic MDCF,
which represents the original input vector.
To find this sequence, the algorithm uses a simple brute-force search over all
possible sequences $\{1,\dots,d\}^*$ with a maximum length of $N$.
We simply try every sequence of possible pivot indices in a breadth-first manner.
So we begin with all sequences of length $1$ and see if any vector occurs twice.
If not, then we continue with all sequences of length $2$ and check again if
any previous vector has occurred twice.
We continue this process indefinitely until we hopefully find a duplicate vector.
To keep track of duplicates, the dictionary \verb|seen| maps vectors to the index,
where they first occurred.

% ==============================================================================
\begin{Python}[
    float=tbp,
    numbers=left,
    caption={
      The implementation of the nondeterministic search.
      The search begins with the empty sequence and then queries the strategy
      for the next valid sequences.
      At the same time, it checks whether any vector has occurred twice
      and stops once it has found a duplicate.
    },
    label={lst:nondet-search},
  ]
def nondeterministic_search(x, N, strat):
  d = len(x)
  sequences = [[]]
  for n in range(N):
    new_sequences = []
    for L in sequences:
      y = x
      seen = {y: 0}
      for l in L:
        y = pivot(y, l)
        seen[y] = i + 1
      for l in strat(x, L):
        z = pivot(y, l)
        if z in seen:
          j = seen[z]
          start = L[:j]
          period = L[j:i+1]
          return start, period
        new_sequences.append(L + [l])
    sequences = new_sequences
\end{Python}
% ==============================================================================

% Nondeterministic search
The main goal of the brute-force search is to find a periodic representation for a cubic root at all.
The problem is that the search is quite expensive.
For a given maximum search depth, the search will take $O(d^n)$ steps,
so even for the lowest dimension $d = 2$, the search is already expensive.
The hope is that the sequences share something in common such that we can find
a more optimized search strategy, ideally one which can be decided without
trying every possible combination.
Therefore, two more types of searches were studied.
The first type is a deterministic search,
which only looks at one possible path in the tree.
For example, the minimum strategy would only look at one possible path.
The other type is a non-deterministic search,
which looks at multiple paths simultaneously.
For this type of search, the main point of interest was the approximation rate of the convergents
and whether convergents are the best rational approximations of the original input vector $x$,
i.e. whether they fulfill
\[
  \left|x_i - \frac{p_i^{(n)}}{q^{(n)}}\right| < \frac{1}{q^{(n)} \sqrt[d]{q^{(n)}}}, \text{ for every } i ≤ d
\]
at each step.
The idea would be that this could be one possible optimization to the brute-force search.
Instead of trying every possible candidate, we only choose paths which lead to good approximations.
For $d = 1$, this is already known by Lemma~\ref{lem:cf-approx},
but for higher dimensions it is not known whether the convergents are good
approximations, yet.

The strategy is given the initial input $x ∈ ℝ^d$ and a sequence of indices $L
∈ \{1, …, d\}^*$ and must return all valid indices which can be appended to the
current sequence to form a new sequence.
For the brute-force search, the strategy always outputs the entire set; any index is allowed.
The minimum strategy only outputs one index and its the one where $x^{(n)}$ has
the minimum fractional value, if $n$ is the length of the list $L$.
\[
  \texttt{strat} \colon ℝ^d → \mathcal P(\{1, …, d\}), x ↦ \{ℓ_1, …, ℓ_k\}.
\]

% Deterministic search
For the deterministic search, a strategy $s$ is a function $R^d → \{1, …, d\}$
which takes in the complete quotient $x^{(n)} ∈ ℝ^d$ of the input vector $x ∈ R^d$
and the number of iterations $n$.
The strategy outputs only a single index $ℓ$,
which is used to find the next complete quotient by $x^{(n+1)} =
\mathrm{pivot}_ℓ(x^{(n)})$.
For example, the minimum strategy would be defined as
\[
  \texttt{strat}(x, n) = \underset{\substack{ℓ ∈ \{1, …, d\} \\ \{x_ℓ\} ≠ 0}}{\text{arg min}} \{x_ℓ\}.
\]
The additional index $n$ is used for example in the Jacobi-Perron algorithm,
which chooses always the next index in the sequence.
So,
\[
  \texttt{strat}(x, n) = (n \bmod d) + 1.
\]

For the non-deterministic search, only the approximation criterion was tested,
but with different rates, i.e. whether for some constant $c ≥ 1$,
\[
  \left|x_i - \frac{p_i^{(n)}}{q^{(n)}}\right| < \frac{c}{q^{(n)} \sqrt[d]{q^{(n)}}}, \text{ for every } i ≤ d.
\]

In summary,
there are three different types of searches.
The first is the brute-force search, which is used to find a periodic MDCF at all.
The second is the nondeterministic search, which is used to see how well the
convergents approximate the original input vector.
The third is the deterministic search, which is used to compare the different
strategies.
\fi

\iffalse
% ==============================================================================
\section{Periodic MDCFs for Cube Roots}
% ==============================================================================

% TODO: Measure the times for each MDCF and list them!
For the first search, the cube roots $\sqrt[3]{2}$ to $\sqrt[3]{100}$ were tested.
The MDCFs for these roots is listed in Table~\ref{tbl:cubics}.
For cubic irrationals there are $O(2^n)$ possible sequences,
so the search is already quite expensive.
The search for the first 30 cube roots had a maximum search depth of $24$ and
this already took over two hours to complete.
Almost half of the time was spent on the root for $\sqrt[3]{29}$
and it did not find a representation for this root.
Instead, I used different strategies to find an MDCF for this root.

Regarding the representation of the roots,
there is no perceivable patterns between the roots and their length.
However, this is to be expected since continued fractions also follow no simple
pattern between square roots and their length.
What the MDCFs share in common is that their periods always have an even length
and the period always contains both indices;
that is, there is no periodic sequence consisting solely of one repeated index
(e.g., only ones or only twos).

Apart from the even length, there is one specific set of roots which have a
predetermined period length
and they are the roots with the shortest period, i.e. $\sqrt[3]{2},
\sqrt[3]{3}, \sqrt[3]{9}$ and $\sqrt[3]{28}$.
Out of all observed roots, they have the shortest period with only two indices.
The reason comes from a theorem proven by Bernstein \cite{Bernstein71}.
In his analysis of the Jacobi-Perron algorithm,
he has shown that Jacobi-Perron algorithm is periodic for any root of the form
% TODO: Is the period length always 1?
% TODO: Check the correct conditions. Specifically is c < D correct?
\[
  \sqrt[3]{D^3 + c}, \qquad \text{ where } c < D \text{ and } c|D.
\]
and that the period length is exactly $2$ in the case of cubic irrationals.
So other roots with a short periodic sequence are $\sqrt[3]{65}, \sqrt[3]{66}$,
for example.

\begin{table}[tbp]
  \caption{Representation of $ψ = \sqrt[3]{4}$ using the brute-force search.}
  \label{table:cube-root-4}
  \centering
  \footnotesize
  \input{tables/cube-root-4.tex}
\end{table}

Finding periodic MDCFs for higher dimensions is even more difficult than two dimensions.
There are now $O(d^N)$ possible sequences with a maximum depth of $N$.
So each search is exponentially more expensive than the cubic case.
Some of the easier ones to find were again the roots identified by Bernstein.
\fi

% ==============================================================================
\section{Comparing Methods for Constructing Periodic Multidimensional Continued Fractions of Algebraic Numbers}
% ==============================================================================

The first part of the analysis is meant to find periodic MDCFs for cubic
irrationals.
For the construction, we use the $\mathrm{pivot}$ operation from generalized
Euclidean algorithm and some sequence of indices, which we pivot with.
The choice of our indices essentially defines a tree
with the initial input vector $x$ as the root
and subsequent nodes as complete quotients of one MDCF.
The edges in this tree are the indices $ℓ$, which we use to get from one
complete quotient $x^{(n)}$ to another $x^{(n+1)}$ by computing $x^{(n+1)} =
\mathrm{pivot}_ℓ(x^{(n)})$.
We have found a periodic representation if there is a path from the root to a
node such that the last node occurs twice on the path.

Initially I tried searching for the MDCF of cube roots
using a brute-force search.
For any irrational vector $x$,
I tried every possible sequence of indices,
which could be used for the construction of an MDCF.
Using this search, I was only able to find the cube roots from $\sqrt[3]{2}$
and $\sqrt[3]{32}$ with the exception of $\sqrt[3]{29}$.
The results are listed in Table~\ref{tbl:cubics}.
The MDCFs I found using this search are the shortest possible representation
for the number, when we measure the combined length of the preperiod and
period.
Since there are a total of $O(2^N)$ sequences,
the search took quite a lot of time.
Therefore, I proceeded to look into better strategies,
which could more easily find MDCFs for cube roots.

% ==============================================================================
\begin{Python}[
    float=tbp,
    numbers=left,
    caption={
      The implementation of the search for periodic MDCFs.
      The strategy \texttt{strat} outputs a single index $ℓ$, which is used
      for pivoting.
      The search stops once a duplicate vector $x$ has been found and the
      program returns the preperiod and period once found.
    },
    label={lst:det-search},
  ]
def search(x, N, strat):
  seen = {x: 0}
  for n in range(N):
    l = strat(x)
    x = pivot(x, l)
    if x in seen:
      j = seen[x]
      start = L[:j]
      period = L[j:i+1]
      return start, period
    else:
      seen[y] = i + 1
\end{Python}
% ==============================================================================

\begin{table}[tbp]
  \caption{
    The shortest periodic MCFs for cube roots found using a
    brute-force search. The maximum search depth was set to $20$ and
    only the sequence for $29$ was not found. The roots for $8$ and $27$ are
    omitted since they are perfect cubes.}
  \label{tbl:cubics}
  \centering
  % TODO: Remove the index sequence from the representation
  \input{tables/cubics2.tex}
\end{table}

The code used for the comparison is shown in Listing~\ref{lst:det-search}.
It is a search on the tree guided by a specific strategy.
Each strategy is given the current input vector $x^{(n)}$ beginning with $x^{(0)} = x$.
It would then output one index $ℓ$ and the search would continue with
$x^{(1)} = \mathrm{pivot}_ℓ(x^{(0)})$.
The search would continue until we find a duplicate vector $x^{(n)} = x^{(m)}$
with $n < m$ on the path determined by the strategy.
Since they are the same, $x^{(n)}$ would mark the beginning of the period.

In these experiments, I focused on the cubic case with $d=2$, testing vectors of
the form $(\sqrt[3]{n}, \sqrt[3]{n^2})$, where $n$ is an integer from $2$ to $1000$.
Each strategy was applied to these inputs with a maximum of $1000$ iterations per run.
A periodic representation was considered successfully found if a duplicate
vector appeared within this step limit. If no such duplicate occurred, the
strategy was marked as unsuccessful for that input.
In summary, the following strategies were tried:
\begin{itemize}
  \item $\textbf{Min}, \textbf{Max}$: Choosing the minimum and maximum fractional value, respectively.
    These are the strategies which have been analyzed in Chapter~\ref{ch:fibonacci}.
  \item $\textbf{JPA}$: The Jacobi-Perron algorithm,
    which chooses indices in a fixed order.
    Specifically, it chooses the indices $1, 2, …, d$, and repeats this sequence indefinitely.
  \item $\textbf{JPA}\star$: A modification of the Jacobi-Perron algorithm introduced by Podsypanin \cite{Podsypanin77}.
    Given a vector $x = (x₁, x₂)$ it chooses the index
    \[
      ℓ =
      \begin{cases}
        1, & \text{ if } x₁ > x₂, \\
        2, & \text{ if } x₁ < x₂.
      \end{cases}
    \]
    For higher dimensions, the algorithm chooses the largest element in $x$.
  \item $\textbf{TY}$:
    The algorithm of Tamura and Yasutomi \cite{Tamura09},
    which is based on the idea of the modified JPA.
    Given vector $x = (x₁, x₂)$, the algorithm chooses the index
    \[
      ℓ =
      \begin{cases}
        1, & \text{ if } \frac{x₁}{\sqrt{|N(x₁)|}} > \frac{x₂}{\sqrt{|N(x₂)|}}, \\
        2, & \text{ if } \frac{x₁}{\sqrt{|N(x₁)|}} < \frac{x₂}{\sqrt{|N(x₂)|}}.
      \end{cases}
    \]
    Again, the algorithm chooses the largest element in each iteration.
    However, it scales down each element by the square root of its norm.
    For higher dimensions, the algorithm chooses
    \[
      ℓ = \argmax_i \frac{x_i}{\sqrt[d]{|N(x_i)|}}.
    \]
    % TODO: Mention that the Tamura and Yasutomi algorithm was tested by the authors themselves for both cubic and quadratic cases.
    The authors have proven that the vector
    $(\sqrt[3]{m^3+1} - m, \sqrt[3]{(m^3 + 1)^2} - m^2)$ is periodic under their algorithm
    as well as any vector $(α, α^2)$, where $α$ is an algebraic number defined by $x^3 - mx + 1 = 0$ with $m ≥ 3$.
    However, their testing has shown that it is periodic for many other cubic
    irrationals.
  \item $\textbf{CC}$: Choosing the closest convergent.
    Out of the $d$ possible indices,
    we choose the one which produces the closest convergent $r^{(n)}$,
    which means that it minimizes the distance to the original input vector.
    This is measured either using the Euclidean norm $\|x - r^{(n)}\|_2$ or using the maximum norm $\|x - r^{(n)}\|_{\infty}$.
\end{itemize}

\begin{figure}[tbp]
  \centering
  \includestandalone{figures/comparison}
  \caption{
    The number of periodic MCFs found using the strategies described in the text.
    A total of $990$ cube roots were tested ranging from $\sqrt[3]{2}$ to $\sqrt[3]{999}$.
  }
  \label{fig:comparison}
\end{figure}

Figure~\ref{fig:comparison} shows the results for this section.
The clear winner is the algorithm by Tamura and Yatusomi.
It has found a periodic representation for almost every cubic irrational I tested.
The only cube roots it didn't find were the largest roots,
since at that point the maximum number of steps is too low.
Increasing the maximum solves the issue and the strategy would have also found
a periodic representation for these roots.
The JPA and the Min strategy faired slightly worse and managed to find a
periodic representation for only 10\% of the roots.
By far the worst strategies were choosing the closest convergents and choosing
the maximum fractional value.

Since Tamura and Yasutomi's algorithm worked so well,
I have also tested it on fifth, sixth and seventh roots
from $\sqrt[d]{2}$ up to $\sqrt[d]{200}$.
Beginning with the fifth roots, the algorithm no longer returns a periodic MDCF for all roots.
In fact, I have only found periodic MDCFs for the following roots:
\begin{itemize}
  \item Fifth roots:
    $\sqrt[5]{2}, \sqrt[5]{7}, \sqrt[5]{11}, \sqrt[5]{13}, \sqrt[5]{19},
    \sqrt[5]{25}, \sqrt[5]{29}, \sqrt[5]{31}, \sqrt[5]{33}, \sqrt[5]{59},
    \sqrt[5]{82}, \sqrt[5]{123}, \sqrt[5]{152}$.
  \item Sixth roots: $\sqrt[6]{18}, \sqrt[6]{65}, \sqrt[6]{66},\sqrt[6]{198}$.
  \item Seventh roots: $\sqrt[6]{2}$.
\end{itemize}

In conclusion,
there are many algebraic numbers which have a periodic MCF.
The best strategy for constructing such MCFs seems to be the algorithm of Tamura and Yatsumi.
Although the Jacobi-Perron algorithm is able to find periodic representations
for a significant portion of cube roots, it seems unable to do so for every
cube root.
The modified JPA seems to perform even worse, finding even less roots than the
Jacobi-Perron algorithm.

% ==============================================================================
\section{Application of Multidimensional Continued Fractions in Simultaneous Diophantine Approximation}
% ==============================================================================

The continued fractions play an important role in Diophantine approximation,
where the goal is to approximate real numbers using rational numbers.
In Lemma~\vref{lem:cf-approx}, we have already seen that the convergents
$pₙ/qₙ$ of a continued fraction $x$ approximate the represented number $x$
particularly well.
More specifically, that every convergent satisfies the bound
\[
  \left|α - \frac{pₙ}{qₙ}\right| < \frac{1}{qₙ^2}.
\]
The Lemma also follows from Dirichlet's approximation theorem.

For its multidimensional counterpart,
the question is whether they approximate the vector particularly well.
Approximating a vector instead of a single number is also known as simultaneous
Diophantine approximation.
Given an irrational vector $(α₁, …, α_d)$, the task is to find a good
rational approximation $(p₁/q, …, p_d/q)$ for every number $α_i$ at once.
Using the simultaneous version of Dirichlet's approximation theorem \cite{Schmidt80},
one can show that there are infinitely many rational vectors $(p₁/q, …, p_d/q)$,
which satisfy
\begin{equation}
  \label{eq:sim-approx}
  \left|α_i - \frac{p_i}{q}\right| ≤ \frac{1}{q^{1 + 1/d}}
  \quad
  \text{ for every } i ∈ \{1, …, d\}.
\end{equation}
Such vectors will be called \emph{good rational approximations} of $(α₁, …, α_d)$.
The idea would be that the convergents of MDCFs are such good rational approximations.
However, if that is not the case, there is still a possibility that some path
during the construction has good rational approximations.
From strongest to weakest, I have analyzed the following questions:
\begin{enumerate}
  \item Do all paths have convergents which are good rational approximations?
  \item Is there a path where all convergents are good rational approximations?
  \item Is there a path where infinitely many convergents are good rational approximations?
\end{enumerate}

To answer these question,
I have implemented a breadth-first search over the construction of an MDCF for the vector $x$.
The search begins with the root $x^{(0)} = x$ and it expands a node $x^{(n)} ∈ ℝ^d$
by adding the vector $\mathrm{pivot}_ℓ(x^{(n)})$ for every $ℓ ∈ \{1, …, d\}$ to the queue.
However, it only expands a node $x^{(n)}$
if its convergent vector $r^{(n)}$ is a good approximation,
i.e. satisfies the bound from Equation~\ref{eq:sim-approx}.
Otherwise, the node is considered a leaf.
The search terminates either after a maximum number of steps is reached or if
there are no more nodes in the queue.
The latter of which would show that there are examples, where no path with the
given approximation bound exists.
This covers the first and second questions.
For the third question, I have implemented a brute-force search,
which simply tries all possible sequences to test for the approximation rate.
The goal would be to see how many convergents satisfy the approximation bound.

Figure~\ref{fig:results-approx} shows the results of this analysis.

% TODO: When repeating the period multiple times, does this actually keep the
% approximation bound intact or does it violate it after some point?
For most cubic roots from the previous test,
there are MDCFs which satisfy the approximation bound.
However, they are notably different MDCFs than those found in the brute-force
search.
So some cubic roots can have different MDCFs
and not all of them must necessarily be good simultaneous approximations.

The most surprising result of this analysis is that there are some cubic roots
for which there exists no path which satisfies the approximation bound of Equation~\ref{eq:sim-approx}.
Perron already suggested that his algorithm does not satisfy this bound \cite{Perron07},
so a simple strategy ought to violate the bound at some point.
However, it turns out that no strategy can keep the approximation bound at each step.
One example is the vector $(\sqrt[3]{5}, \sqrt[3]{25})$.
In this case, the number of convergents starts out growing but quickly drops
after only a few number of iterations.

Since not all cubic roots can be approximated well using MDCFs,
I weakened the bound to allow all convergents which satisfy
\[
  \left|x_i - \frac{p_i}{q}\right| < \frac{c}{q^{1 + 1/d}} \qquad \text{ for every } i ≤ d,
\]
where $c$ is some constant independent of $n$.
The specific constant for each root is listed in Table~\ref{tbl:approx-const}.
% TODO: Make the actual table
\begin{table}[tbp]
  \centering
  \begin{tabular}{cc}
    \uzlhline
    Root & Constant \\
    \hline
    TODO & TODO \\
    \uzlhline
  \end{tabular}
  \caption{Approximation constants for the cubic roots.}
  \label{tbl:approx-const}
\end{table}

% TODO: Add plot for growth

% TODO: Add table for numbers which admit good approximations

% TODO: What about transcendental numbers?

% TODO: Conclusion -- They're not as simple as continued fractions, where the
% convergents immediately lead to the best rational approximations. But they
% could still turn out to have good rational approximations on each path.

The analysis shows that not all convergents of an MCF can be the best rational
approximations.
However, the converse is still possible, i.e. that the best rational
approximations are convergents of some MCF.
